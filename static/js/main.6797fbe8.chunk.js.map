{"version":3,"sources":["mic.js","stats.js","serviceWorker.js","index.js","shaders.js"],"names":["getMicMediaStream","a","constraints","audio","videol","navigator","mediaDevices","getUserMedia","console","log","webkitGetUserMedia","Promise","resolve","reject","reqId","makeStats","stats","Stats","showFpsCounter","enabled","document","body","appendChild","dom","style","right","left","requestAnimationFrame","loop","update","cancelAnimationFrame","undefined","removeChild","Boolean","window","location","hostname","match","makeMicAnalyzer","mediaStream","AudioContext","webkitAudioContext","context","Meyda","createMeydaAnalyzer","audioContext","bufferSize","source","createMediaStreamSource","windowingFunction","featureExtractors","serviceWorker","ready","then","registration","unregister","catch","error","message","n","Math","pow","makeGlslCanvas","canvas","createElement","width","devicePixelRatio","height","gl","getContext","antialias","depth","program","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","makeProgram","useProgram","array","Float32Array","map","random","vertexBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","a_position","getAttribLocation","vertexAttribPointer","FLOAT","enableVertexAttribArray","getElementById","setUniforms","b","c","d","u_a","getUniformLocation","u_b","u_c","u_d","uniform1f","onload","analyzer","timestamp","mod","features","get","el","energy","innerHTML","drawArrays","POINTS","sin"],"mappings":"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","file":"static/js/main.6797fbe8.chunk.js","sourcesContent":["export async function getMicMediaStream() {\n  const constraints = { audio: true, videol: false };\n  if (navigator.mediaDevices.getUserMedia) {\n    console.log(\"Using navigator.mediaDevices\");\n    return navigator.mediaDevices.getUserMedia(constraints);\n  } else if (navigator.webkitGetUserMedia || navigator.getUserMedia) {\n    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia;\n    return new Promise((resolve, reject) => {\n      navigator.getUserMedia(constraints, resolve, reject);\n    });\n  }\n}\n","import Stats from \"stats.js\";\n\nfunction makeStats() {\n  // poor man's run once\n  if (makeStats.stats) return makeStats.stats;\n  makeStats.stats = new Stats();\n  return makeStats.stats;\n}\n\nlet reqId;\nexport const showFpsCounter = enabled => {\n  const stats = makeStats();\n  if (enabled && !reqId) {\n    document.body.appendChild(stats.dom);\n    stats.dom.style.right = 0;\n    stats.dom.style.left = null;\n    reqId = requestAnimationFrame(function loop() {\n      stats.update();\n      reqId = requestAnimationFrame(loop);\n    });\n  } else if (!enabled && reqId) {\n    cancelAnimationFrame(reqId);\n    reqId = undefined;\n    document.body.removeChild(stats.dom);\n  }\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import Meyda from 'meyda';\n\nimport { getMicMediaStream } from './mic';\nimport { showFpsCounter } from \"./stats\";\nimport './index.css';\nimport * as serviceWorker from './serviceWorker';\nimport { fragmentShaderCode, vertexShaderCode } from './shaders';\n\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\nasync function makeMicAnalyzer() {\n  const mediaStream = await getMicMediaStream();\n  const AudioContext = window.AudioContext // Default\n  || window.webkitAudioContext // Safari and old versions of Chrome\n  || false;\n  const context = new AudioContext();\n  return Meyda.createMeydaAnalyzer({\n    audioContext: context,\n    bufferSize: 512,\n    source: context.createMediaStreamSource(mediaStream),\n    windowingFunction: 'blackman',\n    // perceptualSharpness, zcr, rms\n    featureExtractors: [\"energy\"],\n  });\n};\n\nconst [a, b, c, d] = [-2.5, -2.0, -1.2, 2.0];\nconst n = Math.pow(2, 20);\n\nfunction makeProgram(gl) {\n  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(vertexShader, vertexShaderCode);\n  gl.compileShader(vertexShader);\n  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(vertexShader);\n\n  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n  gl.shaderSource(fragmentShader, fragmentShaderCode);\n  gl.compileShader(fragmentShader);\n  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(fragmentShader);\n\n  const program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) throw gl.getProgramInfoLog(program);\n  return program;\n}\n\nfunction makeGlslCanvas() {\n  const width = 780;\n  const height = width;\n  const canvas = document.createElement('canvas');\n  canvas.width = width * devicePixelRatio;\n  canvas.height = height * devicePixelRatio;\n  canvas.style = `width: ${width}px; height: ${height}px;`;\n\n  const gl = canvas.getContext(\"webgl\", {antialias: true, depth: false});\n  const program = makeProgram(gl);\n  gl.useProgram(program);\n  const array = new Float32Array(n * 2).map(() => Math.random() * 2 - 1);\n  const vertexBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n  const a_position = gl.getAttribLocation(program, \"a_position\");\n  gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(a_position);\n\n  document.getElementById(\"root\").appendChild(canvas);\n  return { gl, program };\n}\n\nfunction setUniforms(gl, program, a, b, c, d) {\n  const u_a = gl.getUniformLocation(program, \"u_a\")\n  const u_b = gl.getUniformLocation(program, \"u_b\")\n  const u_c = gl.getUniformLocation(program, \"u_c\")\n  const u_d = gl.getUniformLocation(program, \"u_d\")\n  gl.uniform1f(u_a, a);\n  gl.uniform1f(u_b, b);\n  gl.uniform1f(u_c, c);\n  gl.uniform1f(u_d, d);\n}\n\nwindow.onload = async function onLoad() {\n  const analyzer = await makeMicAnalyzer();\n  showFpsCounter(true);\n  const { gl, program } = makeGlslCanvas();\n  requestAnimationFrame(function loop(timestamp) {\n    let mod = 0;\n    if (analyzer) {\n      const features = analyzer.get([\"energy\", \"perceptualSharpness\"]);\n      const el = document.getElementById(\"meyda-debug\");\n      mod = features ? features.energy * 10 : 0;\n      el.innerHTML = `${mod}`;\n    }\n    gl.drawArrays(gl.POINTS, 0, n);\n    setUniforms(gl, program, Math.sin(timestamp / 1000) - 2.0, b, c, d - mod);\n\n    requestAnimationFrame(loop);\n  });\n};\n","export const fragmentShaderCode = `\nprecision highp float;\n\nvarying float v_t;\n\nconst float PI = 3.14159265359;\n\nvec3 cubehelix(float x, float y, float z) {\nfloat a = y * z * (1.0 - z);\nfloat c = cos(x + PI / 2.0);\nfloat s = sin(x + PI / 2.0);\nreturn vec3(\n  z + a * (1.78277 * s - 0.14861 * c),\n  z - a * (0.29227 * c + 0.90649 * s),\n  z + a * (1.97294 * c)\n);\n}\n\nvec3 rainbow(float t) {\nif (t < 0.0 || t > 1.0) t -= floor(t);\nfloat ts = abs(t - 0.5);\nreturn cubehelix(\n  (360.0 * t - 100.0) / 180.0 * PI,\n  1.5 - 1.5 * ts,\n  0.8 - 0.9 * ts\n);\n}\n\nvoid main() {\ngl_FragColor = vec4(rainbow(v_t / 4.0 + 0.25), 1.0);\n}\n`;\n\nexport const vertexShaderCode = `\nprecision highp float;\n\nconst float PI = 3.14159265359;\n\nuniform float u_a;\nuniform float u_b;\nuniform float u_c;\nuniform float u_d;\n\nattribute vec2 a_position;\n\nvarying float v_t;\n\nvoid main() {\nfloat x1, x2 = a_position.x;\nfloat y1, y2 = a_position.y;\nfor (int i = 0; i < 8; i++) {\n  x1 = x2, y1 = y2;\n  x2 = sin(u_a * y1) - cos(u_b * x1);\n  y2 = sin(u_c * x1) - cos(u_d * y1);\n}\nv_t = atan(a_position.y, a_position.x) / PI;\ngl_Position = vec4(x2 / 2.0, y2 / 2.0, 0.0, 1.0);\ngl_PointSize = 1.5;\n}\n`;\n"],"sourceRoot":""}